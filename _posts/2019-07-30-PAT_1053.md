---
layout: post
update: 2019-07-30 16:44:00 +0800
title: 1053 Path of Equal Weight (30 分) PAT甲级真题
categories: PAT
tags: [C++]
abstract: PAT甲级真题-1053 Path of Equal Weight (30 分)
code_highlight: true
gitment: true
---
* TOC
{:toc}
* # 一、题目含义

    * 有一棵猴子树(权重树)，树的每个结点上面是id(从0到N-1)，下面是猴子数量(权重)。遇到一个猴子就要抢你手上的一个炸弹。你现在需要做的就是让猴子把你手上的炸弹全部都抢了，顺便赶紧逃离这棵树，防止被炸死。
    * 输入第一行:N(包含几个结点),M(有几个结点包含子节点),S(你身上背的炸弹总数)
    * 输入第二行:每个结点上包含几个猴子(按顺序排的，从0到N-1)
    * 接下来的M行:第一个参数代表是第几个结点，第二个参数代表它有几个子结点，第三个参数开始就是它的子节点id。
    * 输出:所有能够把身上的炸弹被抢光，并且逃离大树的路径的猴子数量。(**这里需要排序输出,越早能够拿掉炸弹的路径越早输出**)
    * ![img](https://images.ptausercontent.com/212)
* # 二、案例
  
    * **输入:**    
        *   ```none
            20 9 24
            10 2 4 3 5 10 2 18 9 7 2 2 1 3 12 1 8 6 2 2
            00 4 01 02 03 04
            02 1 05
            04 2 06 07
            03 3 11 12 13
            06 1 09
            07 2 08 10
            16 1 15
            13 3 14 16 17
            17 2 18 19
            ```
    * **输出:** 
        *   ```none
            10 5 2 7
            10 4 10
            10 3 3 6 2
            10 3 3 6 2
            ```
* # 三、分析
    
    * 由于这棵树输出的时候希望炸弹越早被猴子抢走越好，所以在建立大树时，猴子越多的子节点放在越前面，这样就能优先遍历到猴子越多的结点了。
    * 这道题要遍历所有的路径才能得到所有的结果。所以DFS还是BFS都可以(不过或许DFS更合适？因为一棵大树的分支可能很多，而从树上到树下的路长度是有限的，固定了。不能大于S，所以使用DFS的话，堆栈会更小)
    * 由于输出要从树根到叶子，而遍历的时候我们已经到达了叶子，这个时候还要找到树根。能够采取的措施
    	1. 1. 遍历的时候在结点就记住路径，虽然最后可以直接遍历出来，但是浪费了不少不必要的空间
    		2. 每个结点运行双向连接，能够根据叶子找到父亲，反向爬到树根。(我采用的就是这种方法，通过迭代的方式来进行反向搜索。)
* # 四、代码
  
    *   ## 方案
    *   ```cpp
        #include <iostream>
        #include <vector>
        #include <stack>
        #include <algorithm>
        
        using namespace std;
        
        struct node {
            int weight;
            int sum_weight = 0;
            int father = 0;
            vector<int> children;
        } *tree;
        
        void out(int id) {
            if (id != 0) {
                out(tree[id].father);
                cout << " ";
            }
            cout << tree[id].weight;
        }
        
        int cmp(int a, int b) {
            return tree[a].weight > tree[b].weight;
        }
        
        int main() {
            ios::sync_with_stdio(0), cin.tie(0);
            int N, M, S, id, num, child_id;
            cin >> N >> M >> S;
            tree = new node[N];
            for (int i = 0; i < N; i++) {
                cin >> tree[i].weight;
            }
            while (M--) {
                cin >> id >> num;
                while (num--) {
                    cin >> child_id;
                    tree[id].children.push_back(child_id);
                    tree[child_id].father = id;
                }
                sort(tree[id].children.rbegin(), tree[id].children.rend(), cmp);
            }
            stack<int> nodes;
            nodes.push(0);
            while (!nodes.empty()) {
                id = nodes.top();
                nodes.pop();
                tree[id].sum_weight = tree[tree[id].father].sum_weight + tree[id].weight;
                if (tree[id].sum_weight >= S) {
                    if (tree[id].sum_weight == S && tree[id].children.empty()) {
                        out(id);
                        cout<<endl;
                    }
                    continue;
                }
                for (auto temp:tree[id].children) {
                    nodes.push(temp);
                }
            }
        }
        ```

**ps:** 本逻辑是傻瓜式代码

* # 参考链接

1. 1. [PAT甲级题目:1053 Path of Equal Weight (30 分)](https://pintia.cn/problem-sets/994805342720868352/problems/994805424153280512)